import "std/fungible_token_interface"

Contract LiquidStaking(
    tokenId: ByteVec,
    symbol: ByteVec,
    name: ByteVec,
    mut gainPerMillisecond: U256, // Percentage of rewardPool to be paid as a reward each millisecond where 1e18 is 100% of the pool
    mut updatedAt: U256,
    mut currentXTokenPrice: U256,
    mut rewardPool: U256,
    mut totalSupply: U256,
    mut owner_: Address,
    mut paused_: Bool
) extends Pauseable(owner_, paused_) implements IFungibleToken {
    event Mint(sender: Address, amount: U256, newSupply: U256)
    event Burn(sender: Address, amount: U256, newSupply: U256)
    event PriceChanged(newPrice: U256)

    // Reward paid per 1 xToken
    pub fn getCurrentRewardPerMillisecond() -> U256 {
        // This might have precision issues? Better `gainPerMillisecond * rewardPool * elapsed / totalSupply`
        let rewardPerMillisecond = gainPerMillisecond * rewardPool / totalSupply

        return rewardPerMillisecond
    }

    pub fn getCurrentPrice() -> U256 {
        if (totalSupply == 0) {
            return currentXTokenPrice
        }

        // let rewardPerMillisecond = getCurrentRewardPerMillisecond()
        let elapsed = blockTimeStamp!() - updatedAt
        let projectedReward = gainPerMillisecond * rewardPool * elapsed / totalSupply // Multiple elapsed first

        let reward = if (projectedReward > rewardPool) rewardPool else projectedReward

        let currentPrice = currentXTokenPrice + reward
        return currentPrice
    }

    @using(updateFields = true)
    fn updatePrice() -> () {
        let newPrice = getCurrentPrice()
        let accumulatedReward = (newPrice - currentXTokenPrice) * totalSupply / 1e18

        if (rewardPool <= accumulatedReward) {
            rewardPool = 0
        } else {
            rewardPool = rewardPool - accumulatedReward
        }
        
        currentXTokenPrice = newPrice
        updatedAt = blockTimeStamp!()

        emit PriceChanged(currentXTokenPrice)
    }

    @using(assetsInContract = true, preapprovedAssets = true, updateFields = true, checkExternalCaller = false)
    pub fn mint(amount: U256) -> () {
        whenNotPaused()
        updatePrice()
        let xTokenAmount = amount * 1e18 / currentXTokenPrice
        
        transferTokenToSelf!(callerAddress!(), tokenId, amount)
        transferTokenFromSelf!(callerAddress!(), selfTokenId!(), xTokenAmount)

        totalSupply = totalSupply + xTokenAmount

        emit Mint(callerAddress!(), xTokenAmount, totalSupply)
    }

    @using(assetsInContract = true, preapprovedAssets = true, updateFields = true, checkExternalCaller = false)
    pub fn burn(xTokenAmount: U256) -> () {
        whenNotPaused()
        updatePrice()
        let tokenAmount = xTokenAmount * currentXTokenPrice / 1e18

        transferTokenToSelf!(callerAddress!(), selfTokenId!(), xTokenAmount)
        transferTokenFromSelf!(callerAddress!(), tokenId, tokenAmount)

        totalSupply = totalSupply - xTokenAmount

        emit Burn(callerAddress!(), xTokenAmount, totalSupply)
    }

    @using(assetsInContract = true, preapprovedAssets = true, updateFields = true, checkExternalCaller = false)
    pub fn topUpRewards(amount: U256) -> () {
        whenNotPaused()
        updatePrice()

        transferTokenToSelf!(callerAddress!(), tokenId, amount)

        rewardPool = rewardPool + amount
    }

    @using(updateFields = true)
    pub fn setGainPerMillisecond(newGainPerMillisecond: U256) -> () {
        onlyOwner(callerAddress!())
        updatePrice()

        gainPerMillisecond = newGainPerMillisecond
    }

    pub fn getTokenId() -> ByteVec {
        return tokenId
    }

    pub fn getSymbol() -> ByteVec {
        return symbol
    }

    pub fn getName() -> ByteVec {
        return name
    }

    pub fn getDecimals() -> U256 {
        return 18
    }

    pub fn getTotalSupply() -> U256 {
        return totalSupply
    }
}
